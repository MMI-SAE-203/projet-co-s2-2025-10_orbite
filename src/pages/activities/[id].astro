---
import HeaderDashboard from '../../components/HeaderDashboard.astro';
import FooterDashboard from '../../components/FooterDashboard.astro';
import EventMap from '../../components/EventMap.astro';
import { getAllEvents, getEventById, getImageUrl } from '../../lib/pocketbase';

// ✅ Mode hybride : getStaticPaths pour les événements existants
export async function getStaticPaths() {
  try {
    // Récupérer tous les événements existants pour générer les routes statiques
    const events = await getAllEvents();
    
    return events.map((event) => ({
      params: { id: event.id },
      props: { event }
    }));
  } catch (error) {
    console.error('Erreur lors de la récupération des événements pour getStaticPaths:', error);
    return [];
  }
}

// ✅ Rendu côté serveur pour les nouveaux événements
export const prerender = false;

const { id } = Astro.params;
let event = Astro.props.event;

console.log('🔍 Page [id].astro - ID demandé:', id);
console.log('📦 Événement depuis props:', event ? 'Présent' : 'Absent');

// ✅ Si l'événement n'est pas dans les props, essayer plusieurs méthodes
if (!event && id) {
  try {
    console.log('🔄 Tentative de chargement côté serveur pour:', id);
    
    // Méthode 1: Récupération directe
    event = await getEventById(id);
    
    if (!event) {
      console.log('❌ Méthode 1 échouée, tentative méthode 2...');
      
      // Méthode 2: Récupération avec délai (au cas où il y aurait un problème de timing)
      await new Promise(resolve => setTimeout(resolve, 1000));
      event = await getEventById(id);
    }
    
    if (!event) {
      console.log('❌ Méthode 2 échouée, tentative méthode 3...');
      
      // Méthode 3: Recherche dans tous les événements
      const allEvents = await getAllEvents();
      event = allEvents.find(e => e.id === id);
      
      if (event) {
        console.log('✅ Événement trouvé via recherche globale');
      }
    }
    
    if (event) {
      console.log('✅ Événement chargé côté serveur:', event.nom_event);
    }
    
  } catch (error) {
    console.error('❌ Erreur lors du chargement côté serveur:', error);
  }
}

// Si toujours pas d'événement, créer une page d'erreur informative
if (!event) {
  console.log('❌ Aucun événement trouvé, redirection vers page d\'erreur');
  // Au lieu de rediriger, on va afficher une page d'erreur avec diagnostic
}

// Fonctions utilitaires
function formatDate(dateString) {
  if (!dateString) return 'Date non spécifiée';
  try {
    const date = new Date(dateString);
    if (isNaN(date.getTime())) return 'Date invalide';
    const options = { 
      weekday: 'long', 
      day: 'numeric', 
      month: 'long', 
      year: 'numeric'
    };
    return date.toLocaleDateString('fr-FR', options);
  } catch (e) {
    console.error("Erreur lors du formatage de la date:", e);
    return 'Date invalide';
  }
}

function cleanHtmlText(text) {
  if (!text) return '';
  if (typeof text === 'object' && text.lat && text.lng) {
    return `Coordonnées: ${text.lat.toFixed(4)}, ${text.lng.toFixed(4)}`;
  }
  if (typeof text === 'string') {
    return text.replace(/<\/?[^>]+(>|$)/g, "");
  }
  return String(text);
}

function getCategoryIcon(category) {
  const icons = {
    'sport': '⚽', 'soirée': '🎉', 'cinéma': '🎬', 'jeux': '🎮',
    'musique': '🎵', 'chill': '😌', 'voyages': '✈️', 'études': '📚',
    'resto': '🍽️', 'rencontres': '👥', 'cuisine': '👨‍🍳', 'shopping': '🛍️',
    'culture': '🎭', 'bien-être': '🧘'
  };
  return icons[category?.toLowerCase()] || '🌟';
}

// Variables pour l'affichage
let mapLat = 47.5101;
let mapLng = 6.7988;
let imageUrl = '';
let currentParticipants = 0;

// ✅ Vérifier si l'événement est passé
let isEventPassed = false;
if (event && event.date_event) {
  const eventDate = new Date(event.date_event);
  const now = new Date();
  isEventPassed = eventDate < now;
}

if (event) {
  if (event.location && typeof event.location === 'object' && event.location.lat && event.location.lng) {
    mapLat = parseFloat(event.location.lat);
    mapLng = parseFloat(event.location.lng);
  }
  
  if (event.image_event) {
    imageUrl = getImageUrl(event, event.image_event);
  }
  
  currentParticipants = event.participe ? event.participe.length : 0;
}
---

<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width" />
  <title>{event ? `Détails de l'activité - ${event.nom_event}` : 'Événement non trouvé'}</title>
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
        crossorigin=""/>
</head>
<body class="min-h-screen bg-gradient-to-b from-purple-950 via-purple-900 to-black">
  <HeaderDashboard />
  
  {!event ? (
    <!-- Page d'erreur -->
    <div class="min-h-screen flex items-center justify-center px-4">
      <div class="max-w-2xl mx-auto text-center text-white">
        <div class="mb-8">
          <div class="text-8xl mb-4">🔍</div>
          <h1 class="text-3xl font-bold mb-4">Événement non trouvé</h1>
          <p class="text-xl text-purple-200 mb-6">
            L'événement avec l'ID <code class="bg-purple-800 px-2 py-1 rounded">{id}</code> n'a pas pu être chargé.
          </p>
        </div>
        
        <div class="space-y-4">
          <a 
            href="/activities" 
            class="px-6 py-3 border border-white text-white rounded-full hover:bg-white hover:text-purple-900 transition-colors"
          >
            ← Retour à la liste
          </a>
        </div>
      </div>
    </div>
  ) : (
    <!-- Contenu normal de l'événement -->
    <div id="main-content" class="min-h-screen">
      <div class="relative">
        <!-- Image de fond avec overlay -->
        <div class="absolute inset-0 z-0">
          <img 
            id="event-image"
            src={imageUrl || "/placeholder.svg"} 
            alt={event.nom_event} 
            class="w-full h-full object-cover"
            onerror="this.style.display='none'; this.nextElementSibling.style.display='flex'"
          />
          
          <!-- Fallback background -->
          <div id="fallback-bg" class={`w-full h-full bg-gradient-to-br from-purple-600 to-purple-900 flex items-center justify-center ${imageUrl ? 'hidden' : 'flex'}`}>
            <div class="text-center p-4">
              <div id="category-icon" class="text-8xl mb-4">{getCategoryIcon(event.categorie_event)}</div>
              <p id="event-title-fallback" class="text-white text-xl font-medium">{event.nom_event}</p>
            </div>
          </div>
          
          <!-- Overlay gradient violet -->
          <div class="absolute inset-0 bg-gradient-to-b from-purple-900/80 via-purple-900/90 to-purple-900"></div>
        </div>

        <!-- Contenu avec espacement ajusté -->
        <div class="relative z-10 px-4 pt-20 pb-24 min-h-screen">
          <div class="max-w-2xl mx-auto text-white">
            
            <h1 class="text-2xl font-bold mb-6">Détails de l'activité</h1>
            
            <div class="space-y-4">
              <!-- Titre -->
              <div>
                <h2 class="text-lg font-semibold">Titre : <span id="event-title" class="font-normal">{event.nom_event}</span></h2>
              </div>
              
              <!-- Date -->
              <div>
                <h2 class="text-lg font-semibold">Date : <span id="event-date" class="font-normal">{formatDate(event.date_event)}</span></h2>
                
                {/* ✅ Indicateur d'événement passé */}
                {isEventPassed && (
                  <div class="mt-2 inline-block bg-red-900/50 text-red-200 px-3 py-1 rounded-full text-sm">
                    <span class="flex items-center gap-1">
                      <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                      </svg>
                      Événement passé
                    </span>
                  </div>
                )}
              </div>
              
              <!-- Lieu -->
              <div>
                <h2 class="text-lg font-semibold">Lieu : <span id="event-location" class="font-normal">{event.lieu_event}</span></h2>
              </div>
              
              <!-- Participants avec avatars -->
              <div>
                <h2 class="text-lg font-semibold">Participants : 
                  <span class="font-normal">
                    <span id="current-participants">{currentParticipants}</span>/<span id="max-participants">{event.nb_users_max}</span> personnes
                  </span>
                </h2>
                
                <!-- Liste des avatars des participants -->
                <div id="participants-avatars" class="flex flex-wrap gap-2 mt-3">
                  <!-- Les avatars seront chargés ici par JavaScript -->
                </div>
                
                <!-- Message si aucun participant -->
                <div id="no-participants" class={`mt-3 text-purple-200 text-sm ${currentParticipants > 0 ? 'hidden' : ''}`}>
                  🎭 Soyez le premier à participer !
                </div>
              </div>
              
              <!-- Description -->
              <div>
                <h2 class="text-lg font-semibold">Description :</h2>
                <p id="event-description" class="mt-1">{cleanHtmlText(event.description_event)}</p>
              </div>
              
              <!-- Localisation avec carte interactive -->
              <div id="map-section" class={event.location ? '' : 'hidden'}>
                <h2 class="text-lg font-semibold mb-3">Localisation :</h2>
                <div class="bg-white/10 backdrop-blur-sm rounded-lg p-4 border border-white/20">
                  <EventMap 
                    height="h-48"
                    initialLat={mapLat}
                    initialLng={mapLng}
                    zoom={15}
                    interactive={true}
                    showLocationPicker={false}
                  />
                  <p id="coordinates-display" class="text-sm text-white/80 mt-2 text-center">
                    📍 {mapLat.toFixed(4)}, {mapLng.toFixed(4)}
                  </p>
                </div>
              </div>
              
              <!-- ✅ Système de points immédiat -->
              <div class="bg-yellow-400/20 border border-yellow-400/50 rounded-lg p-4">
                <h2 class="text-lg font-semibold text-white mb-2">⭐ Système de points</h2>
                <div class="text-yellow-200 text-sm space-y-1">
                  {isEventPassed ? (
                    <>
                      <p>• <strong>Événement terminé :</strong> Les points ont été distribués aux participants</p>
                      <p class="text-red-300 font-medium">Plus possible de participer à cet événement</p>
                    </>
                  ) : (
                    <>
                      <p>• <strong>+10 points</strong> quand vous cliquez "Je participe"</p>
                      <p>• <strong>-10 points</strong> si vous cliquez "Ne plus participer"</p>
                      <p class="text-yellow-300 font-medium">Points attribués immédiatement !</p>
                    </>
                  )}
                </div>
              </div>
              
              <!-- Catégorie -->
              <div>
                <h2 class="text-lg font-semibold">Catégorie : <span id="event-category" class="font-normal">{getCategoryIcon(event.categorie_event)} {event.categorie_event}</span></h2>
              </div>

              <!-- ✅ Section Commentaires -->
              <div class="mt-8">
                <h2 class="text-lg font-semibold mb-4">💬 Commentaires</h2>
                
                <!-- Formulaire d'ajout de commentaire -->
                <div id="comment-form" class="mb-6 bg-white/10 backdrop-blur-sm rounded-lg p-4 border border-white/20">
                  <div class="flex gap-3">
                    <div id="user-avatar-comment" class="flex-shrink-0">
                      <div class="w-10 h-10 rounded-full bg-purple-600 flex items-center justify-center text-white font-medium">
                        👤
                      </div>
                    </div>
                    <div class="flex-1">
                      <textarea
                        id="comment-input"
                        placeholder="Écrivez votre commentaire..."
                        class="w-full bg-white/10 border border-white/30 rounded-lg px-3 py-2 text-white placeholder-white/60 resize-none focus:outline-none focus:border-yellow-400 focus:ring-1 focus:ring-yellow-400"
                        rows="3"
                        maxlength="500"
                      ></textarea>
                      <div class="flex justify-between items-center mt-2">
                        <span id="char-count" class="text-xs text-white/60">0/500</span>
                        <button
                          id="submit-comment"
                          class="bg-yellow-400 hover:bg-yellow-500 text-black font-medium px-4 py-2 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                          disabled
                        >
                          Publier
                        </button>
                      </div>
                    </div>
                  </div>
                </div>

                <!-- Liste des commentaires -->
                <div id="comments-list" class="space-y-4">
                  <!-- Les commentaires seront chargés ici -->
                  <div id="comments-loading" class="text-center py-8">
                    <div class="animate-spin w-6 h-6 border-2 border-yellow-400 border-t-transparent rounded-full mx-auto mb-2"></div>
                    <p class="text-white/60">Chargement des commentaires...</p>
                  </div>
                </div>

                <!-- Message si aucun commentaire -->
                <div id="no-comments" class="text-center py-8 text-white/60 hidden">
                  <div class="text-4xl mb-2">💭</div>
                  <p>Aucun commentaire pour le moment.</p>
                  <p class="text-sm">Soyez le premier à commenter !</p>
                </div>
              </div>
            </div>
            
            <!-- Messages d'état -->
            <div id="auth-warning" class="mt-8 p-4 bg-yellow-900/50 border border-yellow-500 rounded-lg hidden">
              <div class="flex items-center gap-2 text-yellow-200">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.732-.833-2.5 0L4.268 15.5c-.77.833.192 2.5 1.732 2.5z" />
                </svg>
                <span>Vous devez être connecté pour participer à cette activité.</span>
              </div>
            </div>
            
            <div id="event-full" class="mt-8 p-4 bg-red-900/50 border border-red-500 rounded-lg hidden">
              <div class="flex items-center gap-2 text-red-200">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.732-.833-2.5 0L4.268 15.5c-.77.833.192 2.5 1.732 2.5z" />
                </svg>
                <span>Cette activité est complète.</span>
              </div>
            </div>
            
            {/* ✅ Avertissement pour événement passé */}
            <div id="event-passed" class={`mt-8 p-4 bg-red-900/50 border border-red-500 rounded-lg ${isEventPassed ? '' : 'hidden'}`}>
              <div class="flex items-center gap-2 text-red-200">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                <span>Cet événement est déjà passé. Il n'est plus possible de s'y inscrire.</span>
              </div>
            </div>
            
            <!-- Boutons -->
            <div class="mt-16 mb-12">
              <div class="flex flex-row gap-4 items-center">
                <a href="/activities" class="flex-1 text-center px-6 py-4 border border-white text-white rounded-full hover:bg-white hover:text-purple-900 transition-colors text-lg font-medium">
                  Retour à la liste des activités
                </a>
                
                <button 
                  id="participate-btn" 
                  class="flex-1 bg-yellow-400 hover:bg-yellow-500 text-black font-medium py-4 px-6 rounded-full transition-colors text-lg disabled:opacity-50 disabled:cursor-not-allowed"
                  data-event-id={event.id}
                  data-event-passed={isEventPassed.toString()}
                  disabled={isEventPassed}
                >
                  <span id="btn-text">{isEventPassed ? "Événement passé" : "Je participe (+10 points)"}</span>
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  )}
  
  <!-- Messages de succès/erreur -->
  <div id="success-message" class="fixed top-24 right-4 bg-green-600 text-white p-4 rounded-lg shadow-lg transform translate-x-full transition-transform z-50">
    <div class="flex items-center gap-2">
      <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
      </svg>
      <span id="success-text">Action réussie !</span>
    </div>
  </div>
  
  <div id="error-message" class="fixed top-24 right-4 bg-red-600 text-white p-4 rounded-lg shadow-lg transform translate-x-full transition-transform z-50">
    <div class="flex items-center gap-2">
      <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
      </svg>
      <span id="error-text">Une erreur s'est produite</span>
    </div>
  </div>
  
  <FooterDashboard />

  <!-- Leaflet JavaScript -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
          integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
          crossorigin=""></script>

  <!-- PocketBase JavaScript -->
  <script src="https://unpkg.com/pocketbase@0.21.1/dist/pocketbase.umd.js"></script>

  <script define:vars={{ serverEvent: event, eventId: id }}>
    // Variables globales
    let pb;
    let currentUser = null;
    let eventData = serverEvent;
    let isParticipating = false;
    
    // Initialisation
    document.addEventListener('DOMContentLoaded', async () => {
      console.log('🚀 Démarrage de l\'application');
      
      // Initialiser PocketBase
      try {
        pb = new PocketBase('https://pocketbaseprojet.alexandre-demling.fr');
        console.log('✅ PocketBase initialisé');
      } catch (error) {
        console.error('❌ Erreur lors de l\'initialisation de PocketBase:', error);
        showError('Erreur de connexion à la base de données');
        return;
      }
      
      if (eventData) {
        await initEventPage();
      }
    });
    
    async function initEventPage() {
      try {
        console.log('🔄 Initialisation de la page événement');
        
        // Vérifier l'authentification
        await checkAuthentication();
        
        // Charger les données de l'événement
        if (eventData) {
          await loadEventData(eventData.id);
          await loadParticipants(eventData.id);
          setupEventListeners();
          
          // ✅ Charger les commentaires et configurer les listeners
          await loadComments();
          setupCommentListeners();
        }
        
      } catch (error) {
        console.error('❌ Erreur lors de l\'initialisation:', error);
        showError('Erreur lors du chargement de la page');
      }
    }
    
    async function checkAuthentication() {
      try {
        console.log('🔍 Vérification de l\'authentification...');
        
        if (pb.authStore.isValid) {
          currentUser = pb.authStore.model;
          console.log('👤 Utilisateur connecté:', currentUser?.username || currentUser?.email);
        } else {
          console.log('❌ Utilisateur non connecté');
          showAuthWarning();
        }
      } catch (error) {
        console.error('❌ Erreur lors de la vérification de l\'authentification:', error);
        showAuthWarning();
      }
    }
    
    function showAuthWarning() {
      const authWarning = document.getElementById('auth-warning');
      if (authWarning) authWarning.classList.remove('hidden');
      
      const participateBtn = document.getElementById('participate-btn');
      if (participateBtn) {
        participateBtn.disabled = true;
        const btnText = document.getElementById('btn-text');
        if (btnText) btnText.textContent = 'Connexion requise';
      }
    }
    
    async function loadEventData(eventId) {
      try {
        console.log('📋 Chargement des données de l\'événement:', eventId);
        
        // Récupérer l'événement avec les participants
        eventData = await pb.collection('event').getOne(eventId);
        
        console.log('✅ Données de l\'événement chargées:', eventData);
        
        // ✅ Vérifier si l'événement est passé
        const eventDate = new Date(eventData.date_event);
        const now = new Date();
        const isEventPassed = eventDate < now;
        
        if (isEventPassed) {
          console.log('⏰ Cet événement est déjà passé');
          const participateBtn = document.getElementById('participate-btn');
          if (participateBtn) {
            participateBtn.disabled = true;
            participateBtn.setAttribute('data-event-passed', 'true');
            const btnText = document.getElementById('btn-text');
            if (btnText) btnText.textContent = 'Événement passé';
          }
          
          const eventPassedWarning = document.getElementById('event-passed');
          if (eventPassedWarning) eventPassedWarning.classList.remove('hidden');
        }
        
        // Vérifier si l'utilisateur participe déjà
        if (currentUser && eventData.participe) {
          isParticipating = eventData.participe.includes(currentUser.id);
          console.log('🎯 Participation actuelle:', isParticipating);
        }
        
        updateParticipationButton();
        updateParticipantCount();
        
      } catch (error) {
        console.error('❌ Erreur lors du chargement de l\'événement:', error);
        throw error;
      }
    }
    
    async function loadParticipants(eventId) {
      try {
        console.log('👥 Chargement des participants pour l\'événement:', eventId);
        
        // Récupérer l'événement à jour
        const updatedEvent = await pb.collection('event').getOne(eventId);
        console.log('📋 Événement récupéré:', updatedEvent);
        console.log('📋 Liste des participants (IDs):', updatedEvent.participe);
        
        if (!updatedEvent || !updatedEvent.participe || updatedEvent.participe.length === 0) {
          console.log('ℹ️ Aucun participant trouvé');
          showNoParticipants();
          return;
        }
        
        hideNoParticipants();
        
        const participants = [];
        
        // Charger les données de chaque participant avec plus de logs
        for (const userId of updatedEvent.participe) {
          try {
            console.log('🔍 Tentative de chargement de l\'utilisateur:', userId);
            const user = await pb.collection('users').getOne(userId);
            participants.push(user);
            console.log('👤 Participant chargé avec succès:', {
              id: user.id,
              name: user.name || user.username || user.email,
              email: user.email
            });
          } catch (error) {
            console.error('❌ Impossible de charger l\'utilisateur:', userId, error);
            // Ajouter un participant placeholder pour les utilisateurs non trouvés
            participants.push({
              id: userId,
              name: 'Utilisateur inconnu',
              username: 'unknown',
              email: 'unknown@example.com',
              avatar: null
            });
          }
        }
        
        console.log('✅ Total participants chargés:', participants.length);
        console.log('📊 Détails des participants:', participants);
        displayParticipants(participants);
        
        // Mettre à jour le compteur
        updateParticipantCount(participants.length);
        
      } catch (error) {
        console.error('❌ Erreur lors du chargement des participants:', error);
        showNoParticipants();
      }
    }
    
    // ✅ FIX PRINCIPAL: Correction de la fonction displayParticipants
    function displayParticipants(participants) {
      const container = document.getElementById('participants-avatars');
      if (!container) {
        console.warn('⚠️ Container des avatars non trouvé');
        return;
      }
      
      if (participants.length === 0) {
        container.innerHTML = '';
        showNoParticipants();
        return;
      }
      
      console.log('🖼️ Affichage des avatars pour', participants.length, 'participants');
      
      // ✅ Vider le container d'abord
      container.innerHTML = '';
      
      // ✅ Créer les éléments DOM directement au lieu d'utiliser innerHTML
      participants.forEach((participant, index) => {
        let avatarUrl = '';
        
        // Construire l'URL de l'avatar si disponible
        if (participant.avatar) {
          try {
            avatarUrl = pb.files.getUrl(participant, participant.avatar);
          } catch (error) {
            console.warn('⚠️ Erreur lors de la construction de l\'URL avatar:', error);
          }
        }
        
        const displayName = participant.name || participant.username || participant.email || 'Utilisateur';
        
        // ✅ Créer un avatar par défaut avec les initiales
        const initials = displayName.substring(0, 2).toUpperCase();
        const fallbackAvatar = `data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 40 40"><rect width="40" height="40" fill="%23${Math.floor(Math.random()*16777215).toString(16)}" rx="20"/><text x="20" y="25" text-anchor="middle" fill="white" font-family="Arial" font-size="14" font-weight="bold">${initials}</text></svg>`;
        
        // ✅ Créer l'élément DOM directement
        const participantDiv = document.createElement('div');
        participantDiv.className = 'relative';
        participantDiv.setAttribute('data-participant-id', participant.id);
        
        const link = document.createElement('a');
        link.href = `/users/${participant.id}`;
        link.className = 'block';
        
        const img = document.createElement('img');
        img.src = avatarUrl || fallbackAvatar;
        img.alt = displayName;
        img.className = 'w-10 h-10 rounded-full border-2 border-yellow-400 object-cover hover:scale-110 transition-transform cursor-pointer';
        img.title = `Voir le profil de ${displayName}`;
        
        // ✅ Assembler les éléments
        link.appendChild(img);
        participantDiv.appendChild(link);
        container.appendChild(participantDiv);
      });
      
      console.log('✅ Avatars affichés avec succès');
    }
    
    function showNoParticipants() {
      const noParticipants = document.getElementById('no-participants');
      if (noParticipants) noParticipants.classList.remove('hidden');
    }
    
    function hideNoParticipants() {
      const noParticipants = document.getElementById('no-participants');
      if (noParticipants) noParticipants.classList.add('hidden');
    }
    
    function updateParticipationButton() {
      const btn = document.getElementById('participate-btn');
      const btnText = document.getElementById('btn-text');
      
      if (!btn || !btnText) return;
      
      // Si pas connecté
      if (!currentUser) {
        btn.disabled = true;
        btnText.textContent = 'Connexion requise';
        return;
      }
      
      // ✅ Vérifier si l'événement est passé
      const isEventPassed = btn.getAttribute('data-event-passed') === 'true';
      if (isEventPassed) {
        btn.disabled = true;
        btnText.textContent = 'Événement passé';
        return;
      }
      
      const currentParticipants = eventData.participe ? eventData.participe.length : 0;
      const maxParticipants = eventData.nb_users_max || 0;
      
      // Si événement complet et utilisateur ne participe pas
      if (currentParticipants >= maxParticipants && !isParticipating) {
        btn.disabled = true;
        btnText.textContent = 'Événement complet';
        const eventFull = document.getElementById('event-full');
        if (eventFull) eventFull.classList.remove('hidden');
        return;
      }
      
      // Cacher le message d'événement complet si affiché
      const eventFull = document.getElementById('event-full');
      if (eventFull) eventFull.classList.add('hidden');
      
      // ✅ Mettre à jour le bouton selon l'état de participation avec nouveaux textes
      if (isParticipating) {
        btn.classList.remove('bg-yellow-400', 'hover:bg-yellow-500', 'text-black');
        btn.classList.add('bg-red-600', 'hover:bg-red-700', 'text-white');
        btnText.textContent = 'Ne plus participer (-10 points)';
      } else {
        btn.classList.remove('bg-red-600', 'hover:bg-red-700', 'text-white');
        btn.classList.add('bg-yellow-400', 'hover:bg-yellow-500', 'text-black');
        btnText.textContent = 'Je participe (+10 points)';
      }
      
      btn.disabled = false;
    }
    
    function updateParticipantCount(count = null) {
      const participantCount = count !== null ? count : (eventData.participe ? eventData.participe.length : 0);
      const countEl = document.getElementById('current-participants');
      if (countEl) {
        countEl.textContent = participantCount;
      }
      console.log('📊 Compteur de participants mis à jour:', participantCount);
    }
    
    function setupEventListeners() {
      const participateBtn = document.getElementById('participate-btn');
      
      if (participateBtn) {
        console.log('🔗 Configuration du listener pour le bouton participer');
        
        participateBtn.addEventListener('click', async (e) => {
          e.preventDefault();
          console.log('🖱️ Clic sur le bouton participer détecté');
          
          if (!currentUser) {
            console.log('❌ Utilisateur non connecté');
            showError('Vous devez être connecté pour participer');
            return;
          }
          
          // ✅ Vérifier si l'événement est passé
          const isEventPassed = participateBtn.getAttribute('data-event-passed') === 'true';
          if (isEventPassed) {
            console.log('⏰ Impossible de participer à un événement passé');
            showError('Impossible de participer à un événement passé');
            return;
          }
          
          try {
            // Désactiver le bouton pendant le traitement
            participateBtn.disabled = true;
            const btnText = document.getElementById('btn-text');
            if (btnText) btnText.textContent = 'Traitement...';
            
            console.log('🔄 Traitement de la participation...');
            
            if (isParticipating) {
              console.log('➖ Tentative de quitter l\'événement');
              await leaveEvent();
            } else {
              console.log('➕ Tentative de rejoindre l\'événement');
              await joinEvent();
            }
            
          } catch (error) {
            console.error('❌ Erreur lors de la participation:', error);
            showError(error.message || 'Erreur lors de la participation');
          } finally {
            // Réactiver le bouton
            participateBtn.disabled = false;
          }
        });
        
        console.log('✅ Listener configuré avec succès');
      } else {
        console.error('❌ Bouton participer non trouvé');
      }
    }
    
    // ✅ Fonction joinEvent avec vérification d'événement passé
    async function joinEvent() {
      try {
        console.log('➕ Début de l\'inscription à l\'événement');
        
        const eventId = eventData.id;
        
        // Récupérer l'état actuel de l'événement
        const currentEvent = await pb.collection('event').getOne(eventId);
        
        // ✅ Vérifier si l'événement est passé
        const eventDate = new Date(currentEvent.date_event);
        const now = new Date();
        if (eventDate < now) {
          throw new Error('Impossible de participer à un événement passé');
        }
        
        const currentParticipants = currentEvent.participe || [];
        const maxParticipants = currentEvent.nb_users_max || 0;
        
        // Vérifier si l'événement est complet
        if (currentParticipants.length >= maxParticipants) {
          throw new Error('Événement complet');
        }
        
        // Vérifier si l'utilisateur participe déjà
        if (currentParticipants.includes(currentUser.id)) {
          throw new Error('Vous participez déjà à cet événement');
        }
        
        // ✅ ÉTAPE 1: Ajouter 10 points à l'utilisateur IMMÉDIATEMENT
        console.log('⭐ Attribution immédiate de +10 points...');
        const currentPoints = currentUser.points || 0;
        const newPoints = currentPoints + 10;
        
        await pb.collection('users').update(currentUser.id, {
          points: newPoints
        });
        
        console.log(`✅ Points attribués: ${currentPoints} → ${newPoints}`);
        
        // Mettre à jour l'utilisateur local
        currentUser.points = newPoints;
        
        // ✅ ÉTAPE 2: Ajouter l'utilisateur à la liste des participants
        const updatedParticipants = [...currentParticipants, currentUser.id];
        
        console.log('📝 Mise à jour de l\'événement avec nouveaux participants:', updatedParticipants);
        
        eventData = await pb.collection('event').update(eventId, {
          participe: updatedParticipants
        });
        
        console.log('✅ Inscription réussie');
        
        // Mettre à jour l'état local
        isParticipating = true;
        
        // Recharger l'affichage
        await loadParticipants(eventId);
        updateParticipationButton();
        updateParticipantCount();
        
        showSuccess(`Inscription réussie ! +10 points ajoutés (Total: ${newPoints} points)`);
        
      } catch (error) {
        console.error('❌ Erreur lors de l\'inscription:', error);
        throw error;
      }
    }
    
    // ✅ Fonction leaveEvent avec vérification d'événement passé
    async function leaveEvent() {
      try {
        console.log('➖ Début de la sortie de l\'événement');
        
        const eventId = eventData.id;
        
        // Récupérer l'état actuel de l'événement
        const currentEvent = await pb.collection('event').getOne(eventId);
        
        // ✅ Vérifier si l'événement est passé
        const eventDate = new Date(currentEvent.date_event);
        const now = new Date();
        if (eventDate < now) {
          throw new Error('Impossible de quitter un événement passé');
        }
        
        // ✅ ÉTAPE 1: Retirer 10 points à l'utilisateur IMMÉDIATEMENT
        console.log('⭐ Retrait immédiat de -10 points...');
        const currentPoints = currentUser.points || 0;
        const newPoints = Math.max(0, currentPoints - 10); // Ne pas descendre en dessous de 0
        
        await pb.collection('users').update(currentUser.id, {
          points: newPoints
        });
        
        console.log(`✅ Points retirés: ${currentPoints} → ${newPoints}`);
        
        // Mettre à jour l'utilisateur local
        currentUser.points = newPoints;
        
        // ✅ ÉTAPE 2: Retirer l'utilisateur de la liste des participants
        const currentParticipants = currentEvent.participe || [];
        const updatedParticipants = currentParticipants.filter(id => id !== currentUser.id);
        
        console.log('📝 Mise à jour de l\'événement sans l\'utilisateur:', updatedParticipants);
        
        eventData = await pb.collection('event').update(eventId, {
          participe: updatedParticipants
        });
        
        console.log('✅ Sortie réussie');
        
        // Mettre à jour l'état local
        isParticipating = false;
        
        // Recharger l'affichage
        await loadParticipants(eventId);
        updateParticipationButton();
        updateParticipantCount();
        
        showSuccess(`Vous ne participez plus à cette activité. -10 points retirés (Total: ${newPoints} points)`);
        
      } catch (error) {
        console.error('❌ Erreur lors de la sortie:', error);
        throw error;
      }
    }

    // ✅ NOUVELLES FONCTIONS POUR LES COMMENTAIRES
    
    async function submitComment() {
      const input = document.getElementById('comment-input');
      const submitBtn = document.getElementById('submit-comment');
      
      if (!input || !submitBtn) {
        console.error('❌ Éléments du formulaire non trouvés');
        return;
      }
      
      const content = input.value.trim();
      console.log('📝 Contenu du commentaire:', content);
      console.log('📝 Longueur du contenu:', content.length);
      
      if (!content) {
        showError('Veuillez écrire un commentaire');
        return;
      }
      
      try {
        submitBtn.disabled = true;
        submitBtn.textContent = 'Publication...';
        
        console.log('📤 Envoi du commentaire...');
        
        // ✅ Créer FormData avec les bons noms de champs
        const formData = new FormData();
        formData.append('eventId', eventData.id);
        formData.append('comment', content); // ✅ Utiliser 'comment' comme attendu par l'API
        
        // Ajouter les infos utilisateur
        if (currentUser) {
          formData.append('username', currentUser.name || currentUser.username || currentUser.email);
          formData.append('userToken', pb.authStore.token);
        } else {
          formData.append('username', 'Visiteur');
        }
        
        // Debug: afficher le contenu du FormData
        console.log('📋 FormData envoyé:');
        for (let [key, value] of formData.entries()) {
          console.log(`  ${key}: ${value}`);
        }
        
        const response = await fetch('/api/comment', {
          method: 'POST',
          body: formData
        });
        
        console.log('📥 Réponse reçue:', response.status);
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error('❌ Erreur HTTP:', errorText);
          throw new Error(`Erreur ${response.status}: ${errorText}`);
        }
        
        const result = await response.json();
        console.log('✅ Résultat:', result);
        
        if (result.success) {
          input.value = '';
          updateCharCount();
          await loadComments();
          showSuccess('Commentaire publié avec succès !');
        } else {
          throw new Error(result.error || 'Erreur lors de la publication');
        }
        
      } catch (error) {
        console.error('❌ Erreur lors de la publication du commentaire:', error);
        showError(error.message || 'Erreur lors de la publication du commentaire');
      } finally {
        submitBtn.disabled = false;
        submitBtn.textContent = 'Publier';
      }
    }
    
    async function loadComments() {
      try {
        console.log('💬 Chargement des commentaires...');
        
        const response = await fetch(`/api/comment?eventId=${eventData.id}`);
        
        if (!response.ok) {
          throw new Error(`Erreur ${response.status}`);
        }
        
        const comments = await response.json();
        console.log('✅ Commentaires chargés:', comments.length);
        
        displayComments(comments);
        
      } catch (error) {
        console.error('❌ Erreur lors du chargement des commentaires:', error);
        showCommentsError();
      }
    }
    
    async function deleteComment(commentId) {
      if (!confirm('Êtes-vous sûr de vouloir supprimer ce commentaire ?')) {
        return;
      }
      
      try {
        const token = currentUser ? pb.authStore.token : '';
        const response = await fetch(`/api/comment?id=${commentId}&token=${token}`, {
          method: 'DELETE'
        });
        
        const result = await response.json();
        
        if (result.success) {
          await loadComments();
          showSuccess('Commentaire supprimé avec succès !');
        } else {
          throw new Error(result.error || 'Erreur lors de la suppression');
        }
        
      } catch (error) {
        console.error('❌ Erreur lors de la suppression du commentaire:', error);
        showError(error.message || 'Erreur lors de la suppression du commentaire');
      }
    }
    
    // ✅ FIX COMMENTAIRES: Amélioration de la fonction displayComments pour mobile
    function displayComments(comments) {
      const container = document.getElementById('comments-list');
      const loading = document.getElementById('comments-loading');
      const noComments = document.getElementById('no-comments');
      
      if (loading) loading.style.display = 'none';
      
      if (comments.length === 0) {
        if (noComments) noComments.classList.remove('hidden');
        if (container) container.innerHTML = '';
        return;
      }
      
      if (noComments) noComments.classList.add('hidden');
      
      // ✅ Vider le container d'abord
      if (container) container.innerHTML = '';
      
      // ✅ Créer les éléments DOM directement pour éviter les problèmes d'échappement
      comments.forEach(comment => {
        const user = comment.expand?.users;
        const userName = user?.name || user?.username || user?.email || 'Utilisateur';
        
        // ✅ Créer un avatar par défaut avec les initiales ou un emoji
        let userAvatar = '';
        if (user?.avatar) {
          userAvatar = pb.files.getUrl(user, user.avatar);
        } else {
          // Créer un avatar avec les initiales
          const initials = userName.substring(0, 2).toUpperCase();
          userAvatar = `data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 40 40"><rect width="40" height="40" fill="%23${Math.floor(Math.random()*16777215).toString(16)}" rx="20"/><text x="20" y="25" text-anchor="middle" fill="white" font-family="Arial" font-size="14" font-weight="bold">${initials}</text></svg>`;
        }
        
        const commentDate = new Date(comment.created).toLocaleDateString('fr-FR', {
          day: 'numeric',
          month: 'short',
          hour: '2-digit',
          minute: '2-digit'
        });
        
        const isOwnComment = currentUser && comment.users === currentUser.id;
        
        // ✅ Créer l'élément DOM directement
        const commentDiv = document.createElement('div');
        commentDiv.className = 'bg-white/5 backdrop-blur-sm rounded-lg p-4 border border-white/10';
        commentDiv.setAttribute('data-comment-id', comment.id);
        
        const flexContainer = document.createElement('div');
        flexContainer.className = 'flex gap-3';
        
        // Avatar container
        const avatarContainer = document.createElement('div');
        avatarContainer.className = 'flex-shrink-0';
        
        const avatarLink = document.createElement('a');
        avatarLink.href = `/users/${user?.id || 'unknown'}`;
        avatarLink.className = 'block';
        
        const avatarImg = document.createElement('img');
        avatarImg.src = userAvatar;
        avatarImg.alt = userName;
        avatarImg.className = 'w-10 h-10 rounded-full border-2 border-white/20 object-cover hover:scale-110 transition-transform cursor-pointer';
        avatarImg.title = `Voir le profil de ${userName}`;
        
        avatarLink.appendChild(avatarImg);
        avatarContainer.appendChild(avatarLink);
        
        // Content container
        const contentContainer = document.createElement('div');
        contentContainer.className = 'flex-1 min-w-0';
        
        // Header with name and date
        const headerDiv = document.createElement('div');
        headerDiv.className = 'flex items-center justify-between mb-1';
        
        const nameH4 = document.createElement('h4');
        nameH4.className = 'font-medium text-white truncate';
        nameH4.textContent = userName;
        
        const actionsDiv = document.createElement('div');
        actionsDiv.className = 'flex items-center gap-2';
        
        const dateSpan = document.createElement('span');
        dateSpan.className = 'text-xs text-white/60';
        dateSpan.textContent = commentDate;
        
        actionsDiv.appendChild(dateSpan);
        
        // Delete button if own comment
        if (isOwnComment) {
          const deleteBtn = document.createElement('button');
          deleteBtn.className = 'text-red-400 hover:text-red-300 text-xs opacity-60 hover:opacity-100 transition-opacity';
          deleteBtn.textContent = '🗑️';
          deleteBtn.title = 'Supprimer';
          deleteBtn.onclick = () => deleteComment(comment.id);
          actionsDiv.appendChild(deleteBtn);
        }
        
        headerDiv.appendChild(nameH4);
        headerDiv.appendChild(actionsDiv);
        
        // Comment content
        const contentP = document.createElement('p');
        contentP.className = 'text-white/90 text-sm leading-relaxed break-words';
        contentP.textContent = comment.content;
        
        contentContainer.appendChild(headerDiv);
        contentContainer.appendChild(contentP);
        
        flexContainer.appendChild(avatarContainer);
        flexContainer.appendChild(contentContainer);
        commentDiv.appendChild(flexContainer);
        
        container.appendChild(commentDiv);
      });
    }
    
    function showCommentsError() {
      const container = document.getElementById('comments-list');
      const loading = document.getElementById('comments-loading');
      
      if (loading) loading.style.display = 'none';
      
      if (container) {
        container.innerHTML = '';
        const errorDiv = document.createElement('div');
        errorDiv.className = 'text-center py-8 text-red-300';
        errorDiv.innerHTML = `
          <div class="text-4xl mb-2">⚠️</div>
          <p>Erreur lors du chargement des commentaires</p>
        `;
        container.appendChild(errorDiv);
      }
    }
    
    
    function updateCharCount() {
      const input = document.getElementById('comment-input');
      const counter = document.getElementById('char-count');
      const submitBtn = document.getElementById('submit-comment');
      
      if (!input || !counter || !submitBtn) return;
      
      const length = input.value.length;
      counter.textContent = `${length}/500`;
      
      // Activer/désactiver le bouton selon le contenu
      const hasContent = input.value.trim().length > 0;
      const isAuthenticated = currentUser !== null;
      
      submitBtn.disabled = !hasContent || !isAuthenticated;
      
      // Changer la couleur si proche de la limite
      if (length > 450) {
        counter.classList.add('text-red-400');
      } else {
        counter.classList.remove('text-red-400');
      }
    }
    
    function setupCommentListeners() {
      const input = document.getElementById('comment-input');
      const submitBtn = document.getElementById('submit-comment');
      
      if (input) {
        input.addEventListener('input', updateCharCount);
        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
            e.preventDefault();
            submitComment();
          }
        });
      }
      
      if (submitBtn) {
        submitBtn.addEventListener('click', submitComment);
      }
      
      // Charger l'avatar de l'utilisateur dans le formulaire
      if (currentUser) {
        const avatarContainer = document.getElementById('user-avatar-comment');
        if (avatarContainer) {
          let avatarUrl = '';
          
          if (currentUser.avatar) {
            try {
              avatarUrl = pb.files.getUrl(currentUser, currentUser.avatar);
              avatarContainer.innerHTML = '';
              const img = document.createElement('img');
              img.src = avatarUrl;
              img.alt = currentUser.name || currentUser.username || 'Vous';
              img.className = 'w-10 h-10 rounded-full border-2 border-yellow-400 object-cover';
              avatarContainer.appendChild(img);
            } catch (error) {
              // Fallback silencieux vers les initiales
              const initials = (currentUser.name || currentUser.username || 'U').substring(0, 2).toUpperCase();
              const fallbackAvatar = `data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 40 40"><rect width="40" height="40" fill="%23${Math.floor(Math.random()*16777215).toString(16)}" rx="20"/><text x="20" y="25" text-anchor="middle" fill="white" font-family="Arial" font-size="14" font-weight="bold">${initials}</text></svg>`;
              
              avatarContainer.innerHTML = '';
              const img = document.createElement('img');
              img.src = fallbackAvatar;
              img.alt = currentUser.name || currentUser.username || 'Vous';
              img.className = 'w-10 h-10 rounded-full border-2 border-yellow-400 object-cover';
              avatarContainer.appendChild(img);
            }
          } else {
            // Utiliser les initiales si pas d'avatar
            const initials = (currentUser.name || currentUser.username || 'U').substring(0, 2).toUpperCase();
            const fallbackAvatar = `data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 40 40"><rect width="40" height="40" fill="%23${Math.floor(Math.random()*16777215).toString(16)}" rx="20"/><text x="20" y="25" text-anchor="middle" fill="white" font-family="Arial" font-size="14" font-weight="bold">${initials}</text></svg>`;
            
            avatarContainer.innerHTML = '';
            const img = document.createElement('img');
            img.src = fallbackAvatar;
            img.alt = currentUser.name || currentUser.username || 'Vous';
            img.className = 'w-10 h-10 rounded-full border-2 border-yellow-400 object-cover';
            avatarContainer.appendChild(img);
          }
        }
      }
    }
    
    function showSuccess(message) {
      console.log('✅ Affichage du message de succès:', message);
      const successEl = document.getElementById('success-message');
      const textEl = document.getElementById('success-text');
      
      if (successEl && textEl) {
        textEl.textContent = message;
        successEl.classList.remove('translate-x-full');
        
        setTimeout(() => {
          successEl.classList.add('translate-x-full');
        }, 4000);
      }
    }
    
    function showError(message) {
      console.log('❌ Affichage du message d\'erreur:', message);
      const errorEl = document.getElementById('error-message');
      const textEl = document.getElementById('error-text');
      
      if (errorEl && textEl) {
        textEl.textContent = message;
        errorEl.classList.remove('translate-x-full');
        
        setTimeout(() => {
          errorEl.classList.add('translate-x-full');
        }, 4000);
      }
    }

    // Rendre les fonctions globales pour les boutons onclick
    window.deleteComment = deleteComment;
  </script>
</body>
</html>

<style>
  @keyframes fadeInUp {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  @media (max-width: 768px) {
    h1 {
      font-size: 1.5rem !important;
    }
    
    h2 {
      font-size: 1rem !important;
    }
  }

  .space-y-4 .bg-white\/10 {
    transition: all 0.3s ease;
  }

  .space-y-4 .bg-white\/10:hover {
    background: rgba(255, 255, 255, 0.15);
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
  }

  #participants-avatars img {
    transition: all 0.3s ease;
  }

  #participants-avatars img:hover {
    transform: scale(1.1);
    z-index: 10;
  }

  @keyframes spin {
    to {
      transform: rotate(360deg);
    }
  }

  .animate-spin {
    animation: spin 1s linear infinite;
  }
  
  code {
    font-family: 'Courier New', monospace;
    font-size: 0.9em;
  }
</style>
